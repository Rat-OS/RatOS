"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([["8521"],{12822:function(e,n,i){i.r(n),i.d(n,{default:()=>p,frontMatter:()=>o,metadata:()=>r,assets:()=>l,toc:()=>d,contentTitle:()=>s});var r=JSON.parse('{"id":"configuration/adaptive-meshing","title":"Adaptive Meshing (BETA)","description":"RatOS comes with it\'s own adaptive meshing (functionality was previously handled by PAM by Helge Keck), similar to KAMP. When enabled and configured in your slicer, RatOS will only probe the print area and your configured probe location, potentially saving a lot of time on smaller prints on bigger printers. RatOS will keep the resolution of your mesh (probes per mm), so that you always get consistent mesh performance. Contrary to KAMP and PAM, RatOS doesn\'t move your prime location, instead it probes the prime location (constrained by min/max bedmesh settings) a single time and uses the difference between the probe result and your zoffset to dynamically apply a gcode offset only for the prime macro. This ensures no collision with prime blob and the toolhead on small meshes.","source":"@site/versioned_docs/version-2.0.x/configuration/adaptive-meshing.md","sourceDirName":"configuration","slug":"/configuration/adaptive-meshing","permalink":"/docs/2.0.x/configuration/adaptive-meshing","draft":false,"unlisted":false,"editUrl":"https://github.com/Rat-OS/RatOS/edit/v2.x/site/versioned_docs/version-2.0.x/configuration/adaptive-meshing.md","tags":[],"version":"2.0.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Configuring RatOS Macros","permalink":"/docs/2.0.x/configuration/macros"},"next":{"title":"Toolboard Configuration","permalink":"/docs/2.0.x/configuration/toolboards"}}'),t=i("52676"),a=i("23663");let o={sidebar_position:2},s="Adaptive Meshing (BETA)",l={},d=[{value:"Macro configuration",id:"macro-configuration",level:2},{value:"Slicer configuration",id:"slicer-configuration",level:2},{value:"PrusaSlicer / SuperSlicer",id:"prusaslicer--superslicer",level:3},{value:"OrcaSlicer / SoftFever",id:"orcaslicer--softfever",level:3},{value:"Ideamaker",id:"ideamaker",level:3},{value:"Simplify 3D V5",id:"simplify-3d-v5",level:3},{value:"Cura",id:"cura",level:3},{value:"Relative reference index",id:"relative-reference-index",level:2}];function c(e){let n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"adaptive-meshing-beta",children:"Adaptive Meshing (BETA)"})}),"\n",(0,t.jsx)(n.p,{children:"RatOS comes with it's own adaptive meshing (functionality was previously handled by PAM by Helge Keck), similar to KAMP. When enabled and configured in your slicer, RatOS will only probe the print area and your configured probe location, potentially saving a lot of time on smaller prints on bigger printers. RatOS will keep the resolution of your mesh (probes per mm), so that you always get consistent mesh performance. Contrary to KAMP and PAM, RatOS doesn't move your prime location, instead it probes the prime location (constrained by min/max bed_mesh settings) a single time and uses the difference between the probe result and your z_offset to dynamically apply a gcode offset only for the prime macro. This ensures no collision with prime blob and the toolhead on small meshes."}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Adaptive priming is currently ",(0,t.jsx)(n.strong,{children:"NOT"})," supported for Beacon. It is expected to be supported in the near future, once beacon probe results can be read from macros. RatOS will automatically skip priming if Beacon is detected."]})}),"\n",(0,t.jsx)(n.h2,{id:"macro-configuration",children:"Macro configuration"}),"\n",(0,t.jsxs)(n.p,{children:["To enable adaptive priming set ",(0,t.jsx)(n.code,{children:"variable_adaptive_mesh"})," to ",(0,t.jsx)(n.code,{children:"True"})," in your RatOS macro configuration section (if it isn't already there, add it):"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Possible Values"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"variable_adaptive_mesh"}),(0,t.jsx)(n.td,{children:"True / False"}),(0,t.jsx)(n.td,{children:"False"}),(0,t.jsx)(n.td,{children:"Whether to enable adaptive meshing"})]})})]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"If you are currently using PAM, you should delete the PAM includes from printer.cfg before proceeding. Afterwards you can delete the PAM directory and remove the PAM moonraker.conf entry."})}),"\n",(0,t.jsx)(n.h2,{id:"slicer-configuration",children:"Slicer configuration"}),"\n",(0,t.jsx)(n.p,{children:"Adaptive meshing requires that you provide print area coordinates to the START_PRINT macro, you can copy and paste the START_PRINT macro for your slicer below."}),"\n",(0,t.jsx)(n.h3,{id:"prusaslicer--superslicer",children:"PrusaSlicer / SuperSlicer"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"START_PRINT EXTRUDER_TEMP=[first_layer_temperature] BED_TEMP=[first_layer_bed_temperature] X0={first_layer_print_min[0]} Y0={first_layer_print_min[1]} X1={first_layer_print_max[0]} Y1={first_layer_print_max[1]}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"orcaslicer--softfever",children:"OrcaSlicer / SoftFever"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"START_PRINT EXTRUDER_TEMP=[nozzle_temperature_initial_layer] BED_TEMP=[bed_temperature_initial_layer_single] X0={first_layer_print_min[0]} Y0={first_layer_print_min[1]} X1={first_layer_print_max[0]} Y1={first_layer_print_max[1]}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"ideamaker",children:"Ideamaker"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"START_PRINT EXTRUDER_TEMP={temperature_extruder1} BED_TEMP={temperature_heatbed} X0={print_pos_min_x} Y0={print_pos_min_y} X1={print_pos_max_x} Y1={print_pos_max_y}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"simplify-3d-v5",children:"Simplify 3D V5"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"START_PRINT EXTRUDER_TEMP=[extruder0_temperature] BED_TEMP=[bed0_temperature] X0=[build_min_x] Y0=[build_min_y] X1=[build_max_x] Y1=[build_max_y]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cura",children:"Cura"}),"\n",(0,t.jsx)(n.p,{children:"To make adaptive meshing work with Cura you need to install a post processing plugin"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["in cura open menu ",(0,t.jsx)(n.code,{children:"Help -> Show configuration folder"})]}),"\n",(0,t.jsxs)(n.li,{children:["Copy the following and save it as ",(0,t.jsx)(n.code,{children:"MeshPrintSize.py"})," in the ",(0,t.jsx)(n.code,{children:"scripts"})," folder"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# --------------------------------------------------------------------------------\n# Original Version from https://gist.github.com/frankbags\n# https://gist.github.com/frankbags/c85d37d9faff7bce67b6d18ec4e716ff\n#\n# Modified version from https://github.com/kmarty\n# https://github.com/kmarty/klipper_config_km_addons/blob/master/bed_mesh_calibrate/MeshPrintSize.py\n#\n# thank you frankbags and kmarty!\n# --------------------------------------------------------------------------------\n\nimport re #To perform the search and replace.\n\nfrom ..Script import Script\n\nclass MeshPrintSize(Script):\n\n    def getSettingDataString(self):\n        return \"\"\"{\n            \"name\": \"Mesh Print Size\",\n            \"key\": \"MeshPrintSize\",\n            \"metadata\": {},\n            \"version\": 2,\n            \"settings\":{}\n        }\"\"\"\n\n    def execute(self, data):\n        minMaxXY = {'MINX':0,'MINY':0,'MAXX':0,'MAXY':0}\n        re_pattern = re.compile(r'%(' + r'|'.join(minMaxXY.keys()) + r')%')\n        minmax_counter = len(minMaxXY)\n\n        for i in range(len(data)):\n            # in Cura \"layer' != \"line\" :-(\n            for k,v in minMaxXY.items():\n                if minmax_counter:\n                    result = re.search(r';' + k + r':\\s*(\\d*\\.\\d+|\\d+)', data[i])\n                    if result:\n                        minMaxXY[k] = result.group(1)\n                        minmax_counter -= 1\n                else:\n                    if re_pattern.search(data[i]):\n                        data[i] = re.sub(r'%' + k + r'%', v, data[i])\n\n        return data\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:"restart cura"}),"\n",(0,t.jsxs)(n.li,{children:["in cura open menu ",(0,t.jsx)(n.code,{children:"Extensions -> Post processing -> Modify G-Code"})," and select ",(0,t.jsx)(n.code,{children:"Mesh Print Size"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Modify start gcode to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"START_PRINT EXTRUDER_TEMP={material_print_temperature_layer_0} BED_TEMP={material_bed_temperature_layer_0} X0=%MINX% Y0=%MINY% X1=%MAXX% Y1=%MAXY%\n"})}),"\n",(0,t.jsx)(n.h2,{id:"relative-reference-index",children:"Relative reference index"}),"\n",(0,t.jsx)(n.p,{children:"RatOS Adaptive Meshing currently doesn't modify the relative reference index, it's generally not advised to use relative reference index with adaptive meshing."})]})}function p(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},23663:function(e,n,i){i.d(n,{Z:function(){return s},a:function(){return o}});var r=i(75271);let t={},a=r.createContext(t);function o(e){let n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);